import streamlit as st
import os
import sys
from pathlib import Path
import time
from datetime import datetime
import shutil
import zipfile
import io
import traceback
import threading
import queue
import re
import streamlit.components.v1 as components
from dotenv import load_dotenv
from contextlib import redirect_stdout, redirect_stderr

# Load environment variables from .env file
load_dotenv()

# Add the PocketFlow directory to the path
sys.path.insert(0, str(Path(__file__).parent / "PocketFlow-Tutorial-Codebase-Knowledge"))

from flow import create_tutorial_flow
from main import DEFAULT_INCLUDE_PATTERNS, DEFAULT_EXCLUDE_PATTERNS

# Try to import RAG Chatbot - optional feature
try:
    from rag_chatbot import CodebaseRAG
    RAG_AVAILABLE = True
    RAG_IMPORT_ERROR = None
except ImportError as e:
    RAG_AVAILABLE = False
    RAG_IMPORT_ERROR = str(e)

# Page config
st.set_page_config(
    page_title="CodeSensei",
    page_icon="üìö",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Unicode Icons Mapping
ICONS = {
    'book-open': '‚óà', 'info': '‚ìò', 'sparkles': '‚ú¶', 'cpu': '‚óâ', 'layers': '‚ñ¶',
    'globe': '‚óé', 'workflow': '‚ö°', 'github': '‚éá', 'folder': '‚ñ£', 'download': '‚Üì',
    'search': '‚åï', 'list-ordered': '‚â°', 'file-text': '‚ñ§', 'package': '‚ñ¶', 'book': '‚ñ•',
    'code': '‚ü®‚ü©', 'settings': '‚öô', 'folder-input': '‚ñ£', 'sliders': '‚öô', 'file-code': '‚ü®/‚ü©',
    'save': '‚ó´', 'loader': '‚ü≥', 'check': '‚úì', 'loader-2': '‚ü≥', 'git-branch': '‚éá',
    'edit': '‚úé', 'terminal': '‚ñ∂', 'files': '‚ñ•', 'check-circle': '‚úì', 'bar-chart': '‚ñ•',
    'hard-drive': '‚ó´', 'eye': '‚óâ', 'graduation-cap': '‚óÜ', 'navigation': '‚åò',
    'home': '‚åÇ', 'key': '‚óà',
}

def icon(name, size=16):
    """Return a unicode icon"""
    return f'<span style="font-size: {size}px;">{ICONS.get(name, "‚óè")}</span>'

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        color: #ffffff;
    }
    .sub-header {
        font-size: 1.2rem;
        color: #b0b0b0;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 1.5rem;
        border-radius: 8px;
        text-align: center;
    }
    .metric-card h3 {
        font-size: 2rem;
        margin: 0.5rem 0;
        color: #ffffff;
    }
    .metric-card p {
        color: #b0b0b0;
        margin: 0;
    }
    .file-count {
        padding: 0.5rem;
        background: rgba(0, 255, 0, 0.1);
        border-radius: 4px;
        margin-bottom: 1rem;
    }
    .section-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 1rem;
    }
    .section-header i {
        opacity: 0.8;
    }
    .section-header span {
        opacity: 0.9;
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
# Core codebase state
if 'codebase_source' not in st.session_state:
    st.session_state.codebase_source = None
if 'codebase_type' not in st.session_state:
    st.session_state.codebase_type = None
if 'codebase_loaded' not in st.session_state:
    st.session_state.codebase_loaded = False

# Tutorial Generation state
if 'tutorial_running' not in st.session_state:
    st.session_state.tutorial_running = False
if 'tutorial_complete' not in st.session_state:
    st.session_state.tutorial_complete = False
if 'tutorial_progress_log' not in st.session_state:
    st.session_state.tutorial_progress_log = []
if 'tutorial_output_dir' not in st.session_state:
    st.session_state.tutorial_output_dir = None
if 'tutorial_error' not in st.session_state:
    st.session_state.tutorial_error = None
if 'tutorial_files' not in st.session_state:
    st.session_state.tutorial_files = []
if 'message_queue' not in st.session_state:
    st.session_state.message_queue = queue.Queue()
if 'generation_thread' not in st.session_state:
    st.session_state.generation_thread = None
if 'console_output' not in st.session_state:
    st.session_state.console_output = []
if 'current_step' not in st.session_state:
    st.session_state.current_step = None

# Code Intelligence state
if 'complexity_analysis' not in st.session_state:
    st.session_state.complexity_analysis = None
if 'orphan_code_detection' not in st.session_state:
    st.session_state.orphan_code_detection = None
if 'code_similarity' not in st.session_state:
    st.session_state.code_similarity = None
if 'code_patterns' not in st.session_state:
    st.session_state.code_patterns = None

# Code Security state
if 'vulnerability_scan' not in st.session_state:
    st.session_state.vulnerability_scan = None
if 'security_running' not in st.session_state:
    st.session_state.security_running = False

# RAG Chatbot state
if 'rag_chatbot' not in st.session_state:
    st.session_state.rag_chatbot = None
if 'rag_indexed' not in st.session_state:
    st.session_state.rag_indexed = False
if 'rag_stats' not in st.session_state:
    st.session_state.rag_stats = {}
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []

# Helper Functions
class ConsoleCapture:
    """Capture console output and send to message queue while also printing"""
    def __init__(self, msg_queue, original_stdout):
        self.msg_queue = msg_queue
        self.original_stdout = original_stdout
        self.buffer = ""
    
    def write(self, text):
        # Write to original stdout (console)
        self.original_stdout.write(text)
        self.original_stdout.flush()
        
        # Also send to message queue for UI
        if text and text.strip():
            self.buffer += text
            if '\n' in text:
                lines = self.buffer.split('\n')
                for line in lines[:-1]:
                    if line.strip():
                        self.msg_queue.put({
                            "type": "console",
                            "timestamp": datetime.now().strftime("%H:%M:%S"),
                            "message": line.strip()
                        })
                self.buffer = lines[-1]
        return len(text)
    
    def flush(self):
        self.original_stdout.flush()

def process_message_queue():
    """Process messages from the queue (call from main thread)"""
    try:
        while True:
            msg = st.session_state.message_queue.get_nowait()
            if msg["type"] == "log":
                st.session_state.tutorial_progress_log.append({
                    "timestamp": msg["timestamp"],
                    "message": msg["message"],
                    "level": msg["level"]
                })
            elif msg["type"] == "console":
                timestamp = msg.get("timestamp", "")
                message = msg.get("message", "")
                log_line = f"[{timestamp}] {message}" if timestamp else message
                st.session_state.console_output.append(log_line)
                
                st.session_state.tutorial_progress_log.append({
                    "timestamp": timestamp,
                    "message": message,
                    "level": "info"
                })
            elif msg["type"] == "file":
                st.session_state.tutorial_files.append(msg["file_info"])
            elif msg["type"] == "output_dir":
                st.session_state.tutorial_output_dir = msg["path"]
            elif msg["type"] == "step":
                st.session_state.current_step = msg["step"]
            elif msg["type"] == "error":
                st.session_state.tutorial_error = msg["message"]
            elif msg["type"] == "complete":
                st.session_state.tutorial_running = False
                st.session_state.tutorial_complete = msg["success"]
    except queue.Empty:
        pass

def run_tutorial_generation_thread(config, msg_queue):
    """Run the tutorial generation in a background thread"""
    console_capture_stdout = ConsoleCapture(msg_queue, sys.stdout)
    console_capture_stderr = ConsoleCapture(msg_queue, sys.stderr)
    
    try:
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"), 
                       "message": "Starting tutorial generation...", "level": "info"})
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": f"Source: {config['source']}", "level": "info"})
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": f"Language: {config.get('language', 'English')}", "level": "info"})
        
        # Determine output directory and project name
        if config['source_type'] == 'github':
            project_name = config['source'].rstrip('/').split('/')[-1].replace('.git', '')
        else:
            project_name = Path(config['source']).name
        
        expected_output_dir = os.path.join("./output", project_name)
        msg_queue.put({"type": "output_dir", "path": expected_output_dir})
        
        # Create shared dictionary for tutorial flow
        # Handle repo_url - add @ prefix if not already present
        repo_url = config['source'] if config['source_type'] == 'github' else None
        if repo_url and not repo_url.startswith('@'):
            repo_url = f"{repo_url}"
        
        shared = {
            "repo_url": repo_url,
            "local_dir": config['source'] if config['source_type'] == 'local' else None,
            "project_name": project_name,
            "github_token": os.getenv('GITHUB_TOKEN'),
            "output_dir": "./output",
            "include_patterns": DEFAULT_INCLUDE_PATTERNS,
            "exclude_patterns": DEFAULT_EXCLUDE_PATTERNS,
            "max_file_size": 100000,
            "language": config.get('language', 'english').lower(),
            "use_cache": True,
            "max_abstraction_num": 10,
            "files": [],
            "abstractions": [],
            "relationships": {},
            "chapter_order": [],
            "chapters": [],
            "final_output_dir": None
        }
        
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": "Initializing workflow...", "level": "info"})
        
        # Check if GitHub token is needed
        if config['source_type'] == 'github' and not os.getenv('GITHUB_TOKEN'):
            msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                           "message": "‚ö†Ô∏è Warning: No GITHUB_TOKEN found. Private repos may fail.", "level": "warning"})
        
        tutorial_flow = create_tutorial_flow()
        
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": "Running tutorial generation workflow...", "level": "info"})
        
        # Cache downloaded files for chatbot use (if GitHub repo)
        cache_dir = None
        if config['source_type'] == 'github':
            cache_base = Path("./cache")
            cache_dir = cache_base / project_name
            cache_dir.mkdir(parents=True, exist_ok=True)
            msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
        
        # Redirect stdout and stderr to capture console output
        with redirect_stdout(console_capture_stdout), redirect_stderr(console_capture_stderr):
            tutorial_flow.run(shared)
        
        # Save fetched files to cache directory
        if cache_dir and shared.get("files"):
            msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                           "message": f"Saving {len(shared['files'])} files to cache...", "level": "info"})
            for file_path, content in shared["files"]:
                try:
                    cached_file = cache_dir / file_path
                    cached_file.parent.mkdir(parents=True, exist_ok=True)
                    with open(cached_file, 'w', encoding='utf-8') as f:
                        f.write(content)
                except Exception as e:
                    msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                                   "message": f"Error caching file {file_path}: {str(e)}", "level": "warning"})
            
            msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                           "message": f"‚úÖ Files cached successfully at: {cache_dir}", "level": "success"})
        
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": "Tutorial generation complete!", "level": "success"})
        msg_queue.put({"type": "output_dir", "path": shared.get("final_output_dir", expected_output_dir)})
        msg_queue.put({"type": "complete", "success": True})
        
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": f"Error: {str(e)}", "level": "error"})
        msg_queue.put({"type": "log", "timestamp": datetime.now().strftime("%H:%M:%S"),
                       "message": f"Traceback: {error_trace}", "level": "error"})
        msg_queue.put({"type": "error", "message": f"{str(e)}\n\n{error_trace}"})
        msg_queue.put({"type": "complete", "success": False})

def render_markdown_with_mermaid(markdown_content):
    """Render markdown content with mermaid diagram support"""
    # Check if there are mermaid diagrams
    if '```mermaid' in markdown_content:
        # Split content by mermaid blocks
        parts = re.split(r'```mermaid\n(.*?)\n```', markdown_content, flags=re.DOTALL)
        
        for i, part in enumerate(parts):
            if i % 2 == 0:
                # Regular markdown
                if part.strip():
                    st.markdown(part)
            else:
                # Mermaid diagram
                mermaid_code = part.strip()
                mermaid_html = f"""
                <div class="mermaid">
                {mermaid_code}
                </div>
                <script type="module">
                    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
                    mermaid.initialize({{ startOnLoad: true, theme: 'dark' }});
                </script>
                """
                components.html(mermaid_html, height=400, scrolling=True)
    else:
        st.markdown(markdown_content)

# Tab Render Functions
def render_tutorial_tab():
    """Render the Tutorial Generation tab"""
    st.markdown("## üìö Tutorial Generation")
    st.markdown("Generate comprehensive, structured tutorials from your codebase.")
    st.markdown("---")
    
    # Configuration section
    if not st.session_state.tutorial_complete and not st.session_state.tutorial_running:
        st.markdown("### ‚öô Configuration")
        
        col1, col2 = st.columns(2)
        
        with col1:
            language = st.selectbox(
                "Tutorial Language",
                ["English", "Spanish", "French", "German", "Chinese", "Japanese"],
                help="Select the language for the generated tutorial"
            )
            
            detail_level = st.select_slider(
                "Detail Level",
                options=["Basic", "Intermediate", "Advanced", "Expert"],
                value="Intermediate",
                help="Select how detailed the tutorial should be"
            )
        
        with col2:
            max_chapters = st.number_input(
                "Maximum Chapters",
                min_value=3,
                max_value=15,
                value=8,
                help="Maximum number of chapters to generate"
            )
            
            include_diagrams = st.checkbox(
                "Include Mermaid Diagrams",
                value=True,
                help="Generate architecture diagrams using Mermaid"
            )
        
        st.markdown("---")
        
        # Generate button
        if st.button("üöÄ Generate Tutorial", type="primary", use_container_width=True):
            # Start tutorial generation
            st.session_state.tutorial_running = True
            st.session_state.tutorial_complete = False
            st.session_state.tutorial_error = None
            st.session_state.console_output = []
            st.session_state.tutorial_progress_log = []
            
            # Prepare configuration
            config = {
                "source": st.session_state.codebase_source,
                "source_type": st.session_state.codebase_type,
                "language": language,
                "detail_level": detail_level,
                "max_chapters": max_chapters,
                "include_diagrams": include_diagrams
            }
            
            # Start background thread
            st.session_state.generation_thread = threading.Thread(
                target=run_tutorial_generation_thread,
                args=(config, st.session_state.message_queue),
                daemon=True
            )
            st.session_state.generation_thread.start()
            st.rerun()
    
    # Show progress if running
    if st.session_state.tutorial_running:
        st.markdown("### ‚ü≥ Generating Tutorial...")
        
        # Process message queue
        process_message_queue()
        
        # Show progress
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        # Estimate progress based on console output
        total_lines = len(st.session_state.console_output)
        progress = min(total_lines / 50, 1.0)
        progress_bar.progress(progress)
        status_text.text(f"Processing... ({int(progress * 100)}% estimated)")
        
        # Show console output
        st.markdown("#### üìã Progress Log")
        if st.session_state.console_output:
            console_text = "\n".join(st.session_state.console_output[-100:])
            st.text_area(
                "Console Output",
                value=console_text,
                height=400,
                disabled=True,
                label_visibility="collapsed"
            )
        
        # Auto-refresh every 2 seconds
        time.sleep(2)
        st.rerun()
    
    # Show results if complete
    if st.session_state.tutorial_complete and st.session_state.tutorial_output_dir:
        st.success("‚úÖ Tutorial Generated Successfully!")
        
        output_path = Path(st.session_state.tutorial_output_dir)
        if output_path.exists():
            md_files = sorted(output_path.glob("*.md"))
            
            if md_files:
                st.markdown("### üìÑ Generated Tutorial")
                
                # Preview section
                selected_chapter = st.selectbox(
                    "Select Chapter to Preview",
                    [f.name for f in md_files]
                )
                
                if selected_chapter:
                    chapter_file = output_path / selected_chapter
                    with open(chapter_file, 'r', encoding='utf-8') as f:
                        chapter_content = f.read()
                    
                    with st.expander(f"Preview: {selected_chapter}", expanded=True):
                        render_markdown_with_mermaid(chapter_content)
                
                # Download section
                st.markdown("### üì• Download Options")
                col1, col2 = st.columns(2)
                
                with col1:
                    # ZIP download
                    zip_buffer = io.BytesIO()
                    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                        for file in md_files:
                            zip_file.write(file, file.name)
                    
                    zip_buffer.seek(0)
                    st.download_button(
                        label="üì¶ Download as ZIP",
                        data=zip_buffer,
                        file_name=f"tutorial_{Path(st.session_state.codebase_source).name}.zip",
                        mime="application/zip",
                        use_container_width=True
                    )
                
                with col2:
                    st.button(
                        "üìÑ Download as PDF",
                        use_container_width=True,
                        help=".pdf"
                    )
        
        # Generate another tutorial
        st.markdown("---")
        if st.button("üîÑ Generate Another Tutorial", use_container_width=True):
            st.session_state.tutorial_complete = False
            st.session_state.tutorial_running = False
            st.session_state.tutorial_output_dir = None
            st.session_state.console_output = []
            st.rerun()
    
    # Show error if any
    if st.session_state.tutorial_error:
        st.error(f"‚ùå Error occurred: {st.session_state.tutorial_error}")
        if st.button("üîÑ Try Again"):
            st.session_state.tutorial_running = False
            st.session_state.tutorial_complete = False
            st.session_state.tutorial_error = None
            st.rerun()

def render_intelligence_tab():
    """Render the Code Intelligence tab"""
    st.markdown("## üß† Code Intelligence")
    st.markdown("Deep analysis of your codebase structure and quality.")
    st.markdown("---")
    
    intel_tab1, intel_tab2, intel_tab3, intel_tab4 = st.tabs([
        "üìä Complexity & Maintainability",
        "üîç Orphan Code Detection",
        "üîó Code Similarity",
        "üéØ Pattern Mining"
    ])
    
    with intel_tab1:
        st.markdown("### Code Complexity & Maintainability Analysis")
        st.info("Analyze cyclomatic complexity, maintainability index, and code metrics")
        
        if st.button("‚ñ∂ Run Complexity Analysis", type="primary"):
            st.warning("‚ö†Ô∏è Feature coming soon! This will analyze:")
            st.markdown("""
            - Cyclomatic complexity per function/method
            - Maintainability index
            - Lines of code metrics
            - Code duplication percentage
            - Halstead complexity measures
            """)
    
    with intel_tab2:
        st.markdown("### Orphan Code Detection")
        st.info("Find unused functions, classes, and modules that can be safely removed")
        
        if st.button("‚ñ∂ Detect Orphan Code", type="primary"):
            st.warning("‚ö†Ô∏è Feature coming soon! This will identify:")
            st.markdown("""
            - Unused functions and methods
            - Unreferenced classes
            - Dead code paths
            - Unused imports
            - Orphaned modules
            """)
    
    with intel_tab3:
        st.markdown("### Code Similarity Clustering")
        st.info("Identify duplicate or similar code patterns for potential refactoring")
        
        if st.button("‚ñ∂ Analyze Code Similarity", type="primary"):
            st.warning("‚ö†Ô∏è Feature coming soon! This will show:")
            st.markdown("""
            - Similar code blocks
            - Duplicate functions
            - Near-duplicate code segments
            - Refactoring opportunities
            - Clone detection results
            """)
    
    with intel_tab4:
        st.markdown("### Code Pattern Mining")
        st.info("Discover design patterns and anti-patterns in your codebase")
        
        if st.button("‚ñ∂ Mine Code Patterns", type="primary"):
            st.warning("‚ö†Ô∏è Feature coming soon! This will detect:")
            st.markdown("""
            - Design patterns (Singleton, Factory, Observer, etc.)
            - Anti-patterns (God Object, Spaghetti Code, etc.)
            - Common coding idioms
            - Architecture patterns
            - Best practice violations
            """)

def render_security_tab():
    """Render the Code Security tab"""
    st.markdown("## üîí Code Security Analysis")
    st.markdown("Identify potential security vulnerabilities in your codebase.")
    st.markdown("---")
    
    st.markdown("### Vulnerability Scan Configuration")
    
    col1, col2 = st.columns(2)
    
    with col1:
        scan_depth = st.select_slider(
            "Scan Depth",
            options=["Quick", "Standard", "Deep", "Exhaustive"],
            value="Standard"
        )
        
        severity_filter = st.multiselect(
            "Show Severity Levels",
            ["Critical", "High", "Medium", "Low", "Info"],
            default=["Critical", "High", "Medium"]
        )
    
    with col2:
        scan_categories = st.multiselect(
            "Scan Categories",
            [
                "SQL Injection",
                "XSS",
                "Authentication",
                "Secrets",
                "File Operations",
                "Crypto",
                "All"
            ],
            default=["All"]
        )
    
    st.markdown("---")
    
    if st.button("üîç Run Security Scan", type="primary", use_container_width=True):
        st.warning("‚ö†Ô∏è Feature coming soon! This will scan for:")
        st.markdown("""
        **Common Vulnerabilities:**
        - SQL Injection vulnerabilities
        - Cross-Site Scripting (XSS) risks
        - Insecure authentication patterns
        - Hardcoded secrets and credentials
        - Unsafe file operations
        - Weak cryptography usage
        - Command injection risks
        - Path traversal vulnerabilities
        - Insecure deserialization
        - Missing input validation
        
        **Report Format:**
        - Severity classification
        - Line-by-line location
        - Remediation suggestions
        - OWASP category mapping
        """)

def render_chat_tab():
    """Render the Chat with Code tab"""
    st.markdown("## üí¨ Chat with Code")
    st.markdown("Ask questions about your codebase using AI-powered analysis.")
    st.markdown("---")
    
    if not RAG_AVAILABLE:
        st.error("‚ö†Ô∏è RAG Chatbot dependencies not installed")
        st.markdown("""
        ### Installation Required
        
        ```bash
        pip install chromadb sentence-transformers
        ```
        
        After installation, **restart the Streamlit app**.
        """)
        return
    
    # Index the codebase librarians not already indexed
    if not st.session_state.rag_indexed:
        st.info("‚ÑπÔ∏è Codebase needs to be indexed before chatting")
        
        # Check if tutorial has cached files
        cache_dir = None
        if st.session_state.codebase_type == 'github' and st.session_state.tutorial_complete:
            # Look for cached files from tutorial generation
            cache_base = Path("./cache")
            project_name = Path(st.session_state.codebase_source).name
            cache_dir = cache_base / project_name
            if cache_dir.exists():
                st.info(f"üìÇ Found cached files from tutorial generation at: {cache_dir}")
        
        if st.button("üîÑ Index Codebase for Chat", type="primary", use_container_width=True):
            with st.spinner("Indexing codebase... This may take 1-3 minutes..."):
                try:
                    if not st.session_state.rag_chatbot:
                        st.session_state.rag_chatbot = CodebaseRAG()
                        st.session_state.rag_chatbot.create_collection("codebase")
                    
                    # Use cached directory if available, otherwise use original source
                    index_source = str(cache_dir) if cache_dir and cache_dir.exists() else st.session_state.codebase_source
                    stats = st.session_state.rag_chatbot.index_codebase(index_source)
                    
                    st.session_state.rag_indexed = True
                    st.session_state.rag_stats = stats
                    
                    st.success(f"‚úÖ Indexed {stats['total_files']} files ({stats['total_chunks']} chunks)")
                    
                    time.sleep(1)
                    st.rerun()
                    
                except Exception as e:
                    st.error(f"‚ùå Error indexing codebase: {str(e)}")
        
        st.markdown("""
        ### üéØ Example Questions:
        - "How does authentication work in this codebase?"
        - "Where are database queries defined?"
        - "Explain the payment processing flow"
        - "Find all API endpoints"
        - "Are there any security vulnerabilities?"
        - "What design patterns are used?"
        """)
        return
    
    # Show indexed stats
    with st.expander("‚ÑπÔ∏è Indexed Codebase Info"):
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Files Indexed", st.session_state.rag_stats.get('total_files', 0))
        with col2:
            st.metric("Code Chunks", st.session_state.rag_stats.get('total_chunks', 0))
    
    # Quick action buttons
    if not st.session_state.chat_history:
        st.markdown("---")
    
    # Display chat history
    for message in st.session_state.chat_history:
        if message['role'] == 'user':
            with st.chat_message("user"):
                st.markdown(message['content'])
        else:
            with st.chat_message("assistant"):
                st.markdown(message['content'])
                
                if 'sources' in message:
                    with st.expander("üìÑ Sources"):
                        for source in set(message['sources']):
                            st.markdown(f"- `{source}`")
    
    # Chat input
    user_query = st.chat_input("Ask me anything about the codebase...")
    
    if user_query:
        st.session_state.chat_history.append({
            'role': 'user',
            'content': user_query
        })
        
        with st.spinner("Analyzing code and generating response..."):
            try:
                result = st.session_state.rag_chatbot.answer_query(user_query, n_results=5)
                
                st.session_state.chat_history.append({
                    'role': 'assistant',
                    'content': result['answer'],
                    'sources': result['sources']
                })
                
                st.rerun()
                
            except Exception as e:
                st.error(f"‚ùå Error: {str(e)}")
    
    # Clear chat button
    if st.session_state.chat_history:
        if st.button("üóëÔ∏è Clear Chat History"):
            st.session_state.chat_history = []
            st.rerun()

def render_codebase_input():
    """Render the initial codebase input page"""
    st.markdown('<h1 class="main-header">‚óà CodeSensei</h1>', unsafe_allow_html=True)
    st.markdown("### AI-Powered Code Analysis & Tutorial Generation Platform")
    
    st.markdown("---")
    
    st.markdown("""
    Welcome to CodeSensei! This platform provides comprehensive code analysis and documentation tools.
    
    **Get started by loading your codebase:**
    """)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("### üìÇ Select Codebase Source")
        
        source_type = st.radio(
            "Choose source type:",
            ["GitHub Repository", "Local Directory"],
            horizontal=True,
            key="source_type_selector"
        )
        
        if source_type == "GitHub Repository":
            codebase_input = st.text_input(
                "GitHub Repository URL",
                placeholder="https://github.com/username/repository",
                help="Enter the full GitHub repository URL"
            )
            input_type = "github"
        else:
            codebase_input = st.text_input(
                "Local Directory Path",
                placeholder="/path/to/your/codebase",
                help="Enter the absolute path to your local codebase"
            )
            input_type = "local"
        
        if st.button("‚ñ∂ Load Codebase", type="primary", use_container_width=True):
            if not codebase_input:
                st.error("‚ö†Ô∏è Please provide a codebase source")
            else:
                # Validate input
                if input_type == "local":
                    if not Path(codebase_input).exists():
                        st.error(f"‚ùå Path does not exist: {codebase_input}")
                        return
                    if not Path(codebase_input).is_dir():
                        st.error(f"‚ùå Path is not a directory: {codebase_input}")
                        return
                
                # Save to session state
                st.session_state.codebase_source = codebase_input
                st.session_state.codebase_type = input_type
                st.session_state.codebase_loaded = True
                st.success(f"‚úÖ Codebase loaded: {codebase_input}")
                
                time.sleep(0.5)
                st.rerun()
    
    with col2:
        st.markdown("### üéØ Features")
        st.markdown("""
        Once loaded, you'll have access to:
        
        - **Tutorial Generation**  
          Generate comprehensive tutorials
        
        - **Code Intelligence**  
          Complexity, orphan detection, clustering, patterns
        
        - **Code Security**  
          Vulnerability detection
        
        - **Chat with Code**  
          Interactive Q&A about your codebase
        """)
    
    # Show platform features
    st.markdown("---")
    st.markdown("## üöÄ Platform Capabilities")
    
    tab1, tab2, tab3, tab4 = st.tabs([
        "üìö Tutorial Generation",
        "üß† Code Intelligence", 
        "üîí Code Security",
        "üí¨ Chat with Code"
    ])
    
    with tab1:
        st.markdown("""
        ### Tutorial Generation
        Automatically generate comprehensive, structured tutorials from any codebase.
        
        **Features:**
        - Multi-chapter tutorials with clear structure
        - Code examples and explanations
        - Mermaid diagrams for architecture visualization
        - Download as ZIP or PDF
        """)
    
    with tab2:
        st.markdown("""
        ### Code Intelligence
        Deep analysis of your codebase structure and quality.
        
        **Analysis Types:**
        - **Code Complexity & Maintainability**: Cyclomatic complexity, maintainability index
        - **Orphan Code Detection**: Find unused functions, classes, and modules
        - **Code Similarity Clustering**: Identify duplicate or similar code patterns
        - **Code Pattern Mining**: Discover design patterns and anti-patterns
        """)
    
    with tab3:
        st.markdown("""
        ### Code Security
        Identify potential security vulnerabilities in your code.
        
        **Detects:**
        - SQL injection vulnerabilities
        - XSS (Cross-Site Scripting) risks
        - Insecure authentication patterns
        - Hardcoded secrets and credentials
        - Unsafe file operations
        """)
    
    with tab4:
        st.markdown("""
        ### Chat with Code
        Ask questions about your codebase using AI-powered RAG (Retrieval-Augmented Generation).
        
        **Examples:**
        - "How does authentication work?"
        - "Where are database queries defined?"
        - "Explain the payment processing flow"
        - "Find all API endpoints"
        """)

def main():
    """Main application"""
    
    # Sidebar
    with st.sidebar:
        st.markdown("### ‚óÜ CodeSensei")
        st.markdown("AI Code Analysis Platform")
        st.markdown("---")
        
        # Show loaded codebase info
        if st.session_state.codebase_loaded:
            st.success("‚úÖ Codebase Loaded")
            st.caption(f"**Source:** {st.session_state.codebase_type.title()}")
            st.caption(f"**Path:** {st.session_state.codebase_source}")
            
            if st.button("üîÑ Change Codebase", use_container_width=True):
                # Clear all state
                st.session_state.codebase_loaded = False
                st.session_state.codebase_source = None
                st.session_state.codebase_type = None
                st.session_state.tutorial_complete = False
                st.session_state.rag_indexed = False
                st.session_state.chat_history = []
                st.rerun()
            
            st.markdown("---")
        
        # Settings Panel
        with st.expander("‚öô Settings", expanded=False):
            st.markdown("**API Configuration**")
            
            # Current API Status
            if os.getenv("GEMINI_API_KEY") or os.getenv("GEMINI_PROJECT_ID"):
                st.success("‚úì Gemini API Configured")
            elif os.getenv("LLM_PROVIDER"):
                st.success(f"‚úì {os.getenv('LLM_PROVIDER')} Configured")
            else:
                st.error("‚úó No API Key Found")
                st.caption("Set GEMINI_API_KEY in .env")
            
            # GitHub Token Status
            st.markdown("**GitHub Token**")
            if os.getenv("GITHUB_TOKEN"):
                st.success("‚úì Token Loaded")
            else:
                st.info("‚ìò No GitHub Token")
                st.caption("Set GITHUB_TOKEN for private repos")
    
    # Main content
    if not st.session_state.codebase_loaded:
        render_codebase_input()
    else:
        # Show tabs for different features
        st.markdown(f'<h1 class="main-header">‚óà CodeSensei</h1>', unsafe_allow_html=True)
        st.caption(f"Analyzing: {st.session_state.codebase_source}")
        st.markdown("---")
        
        # Create tabs
        tab1, tab2, tab3, tab4 = st.tabs([
            "üìö Tutorial Generation",
            "üß† Code Intelligence",
            "üîí Code Security",
            "üí¨ Chat with Code"
        ])
        
        with tab1:
            render_tutorial_tab()
        
        with tab2:
            render_intelligence_tab()
        
        with tab3:
            render_security_tab()
        
        with tab4:
            render_chat_tab()

if __name__ == "__main__":
    main()

